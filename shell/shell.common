
###############################################################################
#
# Shell common configuration
# This file contains common shell settings that work for both bash and zsh
#
###############################################################################

# =============================================================================
# Path Settings
# =============================================================================

# Add common paths
export PATH="/usr/local/bin:$HOME/bin:$HOME/.local/bin:$PATH"
# Homebrew (Intel/macOS 用) 調整
if [[ -d /opt/homebrew/bin ]]; then
  export PATH="/opt/homebrew/bin:$PATH"
fi

# =============================================================================
# Basic Shell Settings
# =============================================================================

# History settings
export HISTSIZE=10000
export SAVEHIST=10000
export HISTFILESIZE=20000
export HISTCONTROL=ignoreboth:erasedups

# Editor settings
export EDITOR=vim
export VISUAL=vim

# Language settings
# Set locale only if available to avoid warnings
if locale -a 2>/dev/null | grep -q "ja_JP.UTF-8"; then
    export LANG=ja_JP.UTF-8
    export LC_ALL=ja_JP.UTF-8
else
    # Fallback to C.UTF-8 or en_US.UTF-8
    if locale -a 2>/dev/null | grep -q "C.UTF-8"; then
        export LANG=C.UTF-8
        export LC_ALL=C.UTF-8
    elif locale -a 2>/dev/null | grep -q "en_US.UTF-8"; then
        export LANG=en_US.UTF-8
        export LC_ALL=en_US.UTF-8
    fi
fi

# =============================================================================
# Grep Configuration
# =============================================================================

# Common config files
if [ -n "$BASH_VERSION" ]; then
  config_files="~/dotfiles ~/.bashrc ~/.bash_profile ~/.profile ~/.bash_login /etc/bash.bashrc /etc/profile /etc/bash_completion"
elif [ -n "$ZSH_VERSION" ]; then
  config_files="~/dotfiles ~/.zshrc ~/.zshenv ~/.zprofile ~/.zlogin ~/.zlogout /etc/zsh* ~/.oh-my-zsh ~/.zsh ~/.zshrc.local"
else
  config_files=""
fi
export config_files

# Build grep command with options
grep_options="--color=auto --exclude-dir={.bzr,CVS,.git,.hg,.svn,.idea,.tox,.venv,venv}"

# Determine which grep to use and build the command
if command -v ggrep >/dev/null 2>&1; then
  alias grep='ggrep'
  grep_command="ggrep $grep_options"
elif command -v /usr/local/bin/grep >/dev/null 2>&1; then
  alias grep='/usr/local/bin/grep'
  grep_command="/usr/local/bin/grep $grep_options"
elif command -v /opt/homebrew/bin/grep >/dev/null 2>&1; then
  alias grep='/opt/homebrew/bin/grep'
  grep_command="/opt/homebrew/bin/grep $grep_options"
else
  grep_command="grep $grep_options"
fi
export grep_command

# =============================================================================
# Du Configuration
# =============================================================================

# Determine which du to use and build the command
du_options="-h"

# Check if du supports GNU-style --max-depth option
# Use a safer test directory that should exist everywhere
test_dir="${TMPDIR:-/tmp}"
if [ -d "$test_dir" ] && du --max-depth=1 "$test_dir" >/dev/null 2>&1; then
  # GNU du
  du_command="du $du_options --max-depth=1"
elif command -v gdu >/dev/null 2>&1 && [ -d "$test_dir" ] && gdu --max-depth=1 "$test_dir" >/dev/null 2>&1; then
  # GNU du as gdu
  alias du='gdu'
  du_command="gdu $du_options --max-depth=1"
elif command -v /usr/local/bin/du >/dev/null 2>&1 && [ -d "$test_dir" ] && /usr/local/bin/du --max-depth=1 "$test_dir" >/dev/null 2>&1; then
  # GNU du in /usr/local/bin
  alias du='/usr/local/bin/du'
  du_command="/usr/local/bin/du $du_options --max-depth=1"
elif command -v /opt/homebrew/bin/du >/dev/null 2>&1 && [ -d "$test_dir" ] && /opt/homebrew/bin/du --max-depth=1 "$test_dir" >/dev/null 2>&1; then
  # GNU du in /opt/homebrew/bin
  alias du='/opt/homebrew/bin/du'
  du_command="/opt/homebrew/bin/du $du_options --max-depth=1"
else
  # BSD du (fallback)
  du_command="du $du_options -d 1"
fi
export du_command

# =============================================================================
# Performance Optimizations
# =============================================================================

# Load performance utilities (lazy-loading framework)
if [ -n "$DOTFILES_DIR" ] && [ -f "$DOTFILES_DIR/shell/performance.sh" ]; then
  source "$DOTFILES_DIR/shell/performance.sh"
fi

# =============================================================================
# Source Common Aliases
# =============================================================================
export DOTFILES_DIR=${DOTFILES_DIR:-$HOME/dotfiles}

# Source common aliases (works for both bash and zsh)
if [ -f "$DOTFILES_DIR/shell/aliases.common" ]; then
  source "$DOTFILES_DIR/shell/aliases.common"
fi

# Source shell-specific aliases (after grep_command is set)
if [ -f "$DOTFILES_DIR/shell/aliases.shell" ]; then
  source "$DOTFILES_DIR/shell/aliases.shell"
fi

# =============================================================================
# Commoon Functions
# =============================================================================

# Function to extract archives
extract() {
  if [[ -f $1 ]]; then
    case $1 in
      *.tar.bz2)   tar xjf $1     ;;
      *.tar.gz)    tar xzf $1     ;;
      *.bz2)       bunzip2 $1     ;;
      *.rar)       unrar e $1     ;;
      *.gz)        gunzip $1      ;;
      *.tar)       tar xf $1      ;;
      *.tbz2)      tar xjf $1     ;;
      *.tgz)       tar xzf $1     ;;
      *.zip)       unzip $1       ;;
      *.Z)         uncompress $1  ;;
      *.7z)        7z x $1        ;;
      *)           echo "'$1' cannot be extracted via extract()" ;;
    esac
  else
    echo "'$1' is not a valid file"
  fi
}

# Function to create directory and cd into it
mkcd() {
  mkdir -p "$1" && cd "$1"
}

# Function to show directory history
dh() {
  dirs -v
}

# Function to show where an alias is defined
grepalias() {
  # Input validation
  if [ $# -eq 0 ]; then
    echo "Usage: grepalias <alias_name> [file1] [file2] ..." >&2
    return 1
  fi

  local alias_name="$1"
  shift || true

  # Determine search files
  if [ "$#" -gt 0 ]; then
    # Use files provided as arguments
    :
  elif [ -n "${config_files:-}" ]; then
    # Parse config_files string into positional parameters
    if [ -n "$BASH_VERSION" ]; then
      # Bash: use eval with proper quoting
      eval "set -- $config_files"
    elif [ -n "$ZSH_VERSION" ]; then
      # Zsh: use word splitting
      set -- ${=config_files}
    else
      # Fallback: simple parsing
      set -- $config_files
    fi
    
    # Expand tilde in file paths
    local expanded_file
    local temp_files=""
    for file in "$@"; do
      case "$file" in
        \~/*) expanded_file="$HOME/${file#\~/}" ;;
        *) expanded_file="$file" ;;
      esac
      temp_files="$temp_files $expanded_file"
    done
    eval "set -- $temp_files"
  else
    set -- "$HOME/.zshrc" "$HOME/.zshenv" "$HOME/.zprofile" "$HOME/.bashrc" "$HOME/.bash_profile" "/etc/zshrc" "/etc/bashrc"
  fi

  # Extract alias definition with better parsing
  local alias_def
  alias_def="$(alias "$alias_name" 2>/dev/null)" || {
    printf 'alias not found: %s\n' "$alias_name" >&2
    return 1
  }


  # Extract right-hand side (more robust parsing)
  local rhs
  # Remove the alias name and equals sign from the beginning
  rhs="${alias_def#*=}"

  # Handle different quoting styles - simplified for consistent patterns
  # This function normalizes the RHS to match how it appears in source files
  normalize_rhs() {
    local input="$1"
    local result="$input"

    # Primary case: Single-quoted string (now the standard pattern)
    if [[ "$result" =~ ^\'.*\'$ ]]; then
      # Remove outer single quotes
      result="${result:1:-1}"
      # Convert escaped single quotes '\'' back to single quotes '
      result="${result//'\''/'}"

    # Fallback case: Double-quoted string (legacy patterns)
    elif [[ "$result" =~ ^\".*\"$ ]]; then
      # Remove outer double quotes
      result="${result:1:-1}"
      # Convert escaped double quotes \" back to double quotes "
      result="${result//\\\"/\"}"

    # Simple case: Unquoted single word
    elif [[ "$result" =~ ^[^[:space:]]+$ ]]; then
      # No change needed for unquoted single words
      :

    # Edge case: Malformed quotes (try to salvage)
    else
      # Try to detect and fix malformed patterns
      if [[ "$result" =~ ^\' ]]; then
        # Starts with single quote but doesn't end properly
        result="${result#\'}"
        if [[ "$result" =~ \'$ ]]; then
          result="${result%\'}"
        fi
        result="${result//'\''/'}"
      elif [[ "$result" =~ ^\" ]]; then
        # Starts with double quote but doesn't end properly
        result="${result#\"}"
        if [[ "$result" =~ \"$ ]]; then
          result="${result%\"}"
        fi
        result="${result//\\\"/\"}"
      else
        # Completely unparseable
        printf 'cannot parse alias definition: %s\n' "$alias_def" >&2
        return 1
      fi
    fi

    echo "$result"
  }

  # Normalize the RHS
  rhs="$(normalize_rhs "$rhs")" || return 1

  # Search for the alias definition
  # First try exact match
  grep --color=auto --exclude="*.md" -R -nH -F -- "$rhs" "$@" 2>/dev/null

  # If no exact match found, try searching for the alias name itself
  # This handles cases where variables are expanded or special characters cause issues
  if [ $? -ne 0 ]; then
    grep --color=always --exclude="*.md" -R -nH -E -- "alias $alias_name=" "$@" 2>/dev/null
  fi
}
aliaswh() {
  grepalias "$1"
}
grepal() {
  grepalias "$1"
}

# Function to jump to directory by number
j() {
  if [[ $1 =~ ^[0-9]+$ ]]; then
    local dir=$(dirs -l | sed -n "${1}p" | cut -d' ' -f2-)
    if [[ -n $dir ]]; then
      cd "$dir"
    else
      echo "Directory not found"
    fi
  else
    echo "Usage: j <number>"
  fi
}

gvim() {
  # macOS
  if [[ "$OSTYPE" == darwin* ]]; then
    if command -v mvim >/dev/null 2>&1; then
      command mvim "$@"
    elif [[ -x "/Applications/MacVim.app/Contents/bin/mvim" ]]; then
      "/Applications/MacVim.app/Contents/bin/mvim" "$@"
    else
      if command -v open >/dev/null 2>&1; then
        open -a "MacVim" --args "$@"
      else
        vim -g "$@"
      fi
    fi
    return
  fi

  # WSL (Windows Subsystem for Linux)
  if grep -qi microsoft /proc/version 2>/dev/null; then
    local win_gvim="/mnt/c/Program Files/vim/gvim.exe"
    if [[ -x "$win_gvim" ]]; then
      local args=()
      if command -v wslpath >/dev/null 2>&1; then
        for a in "$@"; do
          if [[ -e "$a" || "$a" == /* ]]; then
            args+=("$(wslpath -w -- "$a")")
          else
            args+=("$a")
          fi
        done
      else
        args=("$@")
      fi
      "$win_gvim" "${args[@]}" >/dev/null 2>&1 &
      disown
      return
    fi
  fi

  # MSYS/Cygwin on Windows
  case "$OSTYPE" in
    msys*|cygwin*)
      local win_gvim="/c/Program Files/vim/gvim.exe"
      if [[ -x "$win_gvim" ]]; then
        local args=()
        if command -v cygpath >/dev/null 2>&1; then
          for a in "$@"; do
            if [[ -e "$a" || "$a" == /* ]]; then
              args+=("$(cygpath -w -- "$a")")
            else
              args+=("$a")
            fi
          done
        else
          args=("$@")
        fi
        "$win_gvim" "${args[@]}" >/dev/null 2>&1 &
        disown
        return
      fi
      ;;
  esac

  # Fallbacks: native gvim or terminal GUI mode
  if command -v gvim >/dev/null 2>&1; then
    command gvim "$@" & disown
  else
    vim -g "$@"
  fi
}

# =============================================================================
# User Local Configuration
# =============================================================================

# Load user-specific customizations (if exists)
# This allows users to override settings without modifying the main dotfiles
# Use positional parameters instead of arrays for better compatibility
set -- "$HOME/.dotfiles-local" "$HOME/.config/dotfiles/local" "$DOTFILES_DIR/shell/local" "$HOME/.dotfiles/shell/local"

for local_config in "$@"; do
  if [ -f "$local_config" ] && [ -r "$local_config" ]; then
    source "$local_config"
    break
  fi
done
