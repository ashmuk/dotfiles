#!/bin/bash
# Comprehensive Bash Runtime Configuration
# Interactive bash shell configuration
# Source: dotfiles/shell/profile/bashrc.comprehensive

# Exit if not interactive
[[ $- != *i* ]] && return

# Prevent recursive sourcing
if [[ -n "$BASHRC_LOADED" ]]; then
    return
fi
export BASHRC_LOADED=1

#---------------------------------------------------------------------------
# Performance Monitoring Setup
#---------------------------------------------------------------------------

if [[ -n "$SHELL_PERFORMANCE_MONITOR" ]]; then
    BASHRC_START_TIME=$(date +%s%N 2>/dev/null || date +%s)
fi

#---------------------------------------------------------------------------
# Shell Options & Behavior
#---------------------------------------------------------------------------

# History management
HISTSIZE=50000
HISTFILESIZE=100000
HISTCONTROL=ignoreboth:erasedups
HISTIGNORE="ls:cd:pwd:exit:date:clear:history"
HISTTIMEFORMAT="%F %T "

# Shell options
shopt -s histappend         # Append to history file
shopt -s checkwinsize       # Update LINES and COLUMNS
shopt -s cdspell           # Minor spelling corrections for cd
shopt -s dirspell          # Minor spelling corrections for directories  
shopt -s autocd            # Auto cd when typing directory name
shopt -s globstar          # ** recursive globbing
shopt -s nocaseglob        # Case-insensitive globbing
shopt -s extglob           # Extended globbing patterns
shopt -s histverify        # Verify history expansions

# Set vi mode for command line editing
set -o vi

#---------------------------------------------------------------------------
# Environment Integration
#---------------------------------------------------------------------------

# Source common shell configuration
DOTFILES_ROOT="${DOTFILES_ROOT:-$HOME/dotfiles}"

if [[ -f "$DOTFILES_ROOT/shell/shell.common" ]]; then
    source "$DOTFILES_ROOT/shell/shell.common"
fi

if [[ -f "$DOTFILES_ROOT/shell/shell.bash" ]]; then
    source "$DOTFILES_ROOT/shell/shell.bash"
fi

#---------------------------------------------------------------------------
# Enhanced Prompt Configuration
#---------------------------------------------------------------------------

# Color definitions
if [[ -x /usr/bin/tput ]] && tput setaf 1 >&/dev/null; then
    # Terminal supports color
    RED=$(tput setaf 1)
    GREEN=$(tput setaf 2)
    YELLOW=$(tput setaf 3)
    BLUE=$(tput setaf 4)
    MAGENTA=$(tput setaf 5)
    CYAN=$(tput setaf 6)
    WHITE=$(tput setaf 7)
    BOLD=$(tput bold)
    RESET=$(tput sgr0)
else
    # No color support
    RED="" GREEN="" YELLOW="" BLUE="" MAGENTA="" CYAN="" WHITE="" BOLD="" RESET=""
fi

# Git status function for prompt
git_prompt() {
    local git_status git_branch
    if git_status=$(git status --porcelain 2>/dev/null); then
        git_branch=$(git symbolic-ref --short HEAD 2>/dev/null || git describe --tags --exact-match 2>/dev/null || git rev-parse --short HEAD 2>/dev/null)
        if [[ -n "$git_branch" ]]; then
            if [[ -n "$git_status" ]]; then
                echo " ${YELLOW}(${git_branch}*)${RESET}"
            else
                echo " ${GREEN}(${git_branch})${RESET}"
            fi
        fi
    fi
}

# Enhanced prompt with git integration
if [[ "$TERM_PROGRAM" == "vscode" ]]; then
    # Simplified prompt for VS Code terminal
    PS1="\[\e[32m\]\u@\h\[\e[0m\]:\[\e[34m\]\w\[\e[0m\]\$(git_prompt) $ "
else
    # Full-featured prompt
    PS1="\[${BOLD}${GREEN}\]\u@\h\[${RESET}\]:\[${BOLD}${BLUE}\]\w\[${RESET}\]\$(git_prompt)\n\[${BOLD}${CYAN}\]❯\[${RESET}\] "
fi

#---------------------------------------------------------------------------
# Enhanced Completion
#---------------------------------------------------------------------------

# Bash completion
if ! shopt -oq posix; then
    completion_sources=(
        "/usr/share/bash-completion/bash_completion"      # Linux
        "/etc/bash_completion"                            # Linux (older)
        "/usr/local/etc/bash_completion"                  # macOS (Intel Homebrew)
        "/opt/homebrew/etc/bash_completion"               # macOS (Apple Silicon Homebrew)
        "/usr/local/share/bash-completion/bash_completion" # Alternative location
    )
    
    for completion_file in "${completion_sources[@]}"; do
        if [[ -f "$completion_file" ]]; then
            source "$completion_file"
            break
        fi
    done
fi

# Git completion (if available separately)
if [[ -f "/usr/local/etc/bash_completion.d/git-completion.bash" ]]; then
    source "/usr/local/etc/bash_completion.d/git-completion.bash"
elif [[ -f "/opt/homebrew/etc/bash_completion.d/git-completion.bash" ]]; then
    source "/opt/homebrew/etc/bash_completion.d/git-completion.bash"
fi

#---------------------------------------------------------------------------
# Aliases & Functions
#---------------------------------------------------------------------------

# Source alias configurations
if [[ -f "$DOTFILES_ROOT/shell/aliases.common" ]]; then
    source "$DOTFILES_ROOT/shell/aliases.common"
fi

if [[ -f "$DOTFILES_ROOT/shell/aliases.shell" ]]; then
    source "$DOTFILES_ROOT/shell/aliases.shell"
fi

# Bash-specific aliases
alias ..='cd ..'
alias ...='cd ../..'
alias ....='cd ../../..'
alias .....='cd ../../../..'

# Enhanced directory listing
if command -v exa >/dev/null 2>&1; then
    alias ls='exa --icons --group-directories-first'
    alias ll='exa -l --icons --group-directories-first --time-style=long-iso'
    alias la='exa -la --icons --group-directories-first --time-style=long-iso'
    alias tree='exa --tree --icons'
elif ls --color=auto >/dev/null 2>&1; then
    alias ls='ls --color=auto --group-directories-first'
    alias ll='ls -l --color=auto --group-directories-first --time-style=long-iso'
    alias la='ls -la --color=auto --group-directories-first --time-style=long-iso'
else
    alias ll='ls -l'
    alias la='ls -la'
fi

# Safety aliases
alias rm='rm -i'
alias cp='cp -i'
alias mv='mv -i'

# Quick navigation
alias home='cd ~'
alias projects='cd ~/Projects'
alias downloads='cd ~/Downloads'
alias documents='cd ~/Documents'

# Utility functions
mkcd() {
    mkdir -p "$1" && cd "$1"
}

extract() {
    if [[ -f "$1" ]]; then
        case "$1" in
            *.tar.bz2)   tar xjf "$1"     ;;
            *.tar.gz)    tar xzf "$1"     ;;
            *.bz2)       bunzip2 "$1"     ;;
            *.rar)       unrar e "$1"     ;;
            *.gz)        gunzip "$1"      ;;
            *.tar)       tar xf "$1"      ;;
            *.tbz2)      tar xjf "$1"     ;;
            *.tgz)       tar xzf "$1"     ;;
            *.zip)       unzip "$1"       ;;
            *.Z)         uncompress "$1"  ;;
            *.7z)        7z x "$1"        ;;
            *)           echo "'$1' cannot be extracted via extract()" ;;
        esac
    else
        echo "'$1' is not a valid file"
    fi
}

#---------------------------------------------------------------------------
# Development Tools Integration
#---------------------------------------------------------------------------

# FZF integration (if available)
if command -v fzf >/dev/null 2>&1; then
    # FZF key bindings and completion
    if [[ -f ~/.fzf.bash ]]; then
        source ~/.fzf.bash
    elif [[ -f /usr/local/opt/fzf/shell/key-bindings.bash ]]; then
        source /usr/local/opt/fzf/shell/key-bindings.bash
        source /usr/local/opt/fzf/shell/completion.bash
    elif [[ -f /opt/homebrew/opt/fzf/shell/key-bindings.bash ]]; then
        source /opt/homebrew/opt/fzf/shell/key-bindings.bash
        source /opt/homebrew/opt/fzf/shell/completion.bash
    fi
    
    # FZF configuration
    export FZF_DEFAULT_OPTS='--height 40% --layout=reverse --border --preview "head -100 {}"'
    export FZF_CTRL_T_COMMAND='find . -type f'
    export FZF_ALT_C_COMMAND='find . -type d'
fi

# Direnv integration (if available)
if command -v direnv >/dev/null 2>&1; then
    eval "$(direnv hook bash)"
fi

# Zoxide integration (if available)
if command -v zoxide >/dev/null 2>&1; then
    eval "$(zoxide init bash)"
    alias cd='z'
fi

#---------------------------------------------------------------------------
# Local Customizations
#---------------------------------------------------------------------------

# Source local bashrc customizations
local_bashrc_files=(
    "$HOME/.bashrc.local"
    "$HOME/dotfiles/shell/profile/local.bashrc"
    "$DOTFILES_ROOT/shell/local.bash"
)

for local_file in "${local_bashrc_files[@]}"; do
    if [[ -f "$local_file" ]]; then
        source "$local_file"
    fi
done

#---------------------------------------------------------------------------
# Performance Monitoring Conclusion
#---------------------------------------------------------------------------

if [[ -n "$SHELL_PERFORMANCE_MONITOR" ]] && [[ -n "$BASHRC_START_TIME" ]]; then
    BASHRC_END_TIME=$(date +%s%N 2>/dev/null || date +%s)
    BASHRC_LOAD_TIME=$((BASHRC_END_TIME - BASHRC_START_TIME))
    echo "Bashrc loaded in ${BASHRC_LOAD_TIME}ns" >&2
fi

# Welcome message
if [[ -z "$DOTFILES_QUIET" ]] && [[ -n "$PS1" ]]; then
    echo "💻 Interactive Bash session ready! ($(bash --version | head -1))"
fi